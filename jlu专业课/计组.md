### 概述  
计算机系统:硬件系统和软件系统(外设和软件)
		软件:系统软件(操作系统)和应用软件()

五大设备，以前是运算器中心 现在是存储器

主机:运算器，控制器，存储器(主存)
外设: 输入输出，辅助存储器
cpu:运算器，控制器

m4高级语言机器m3汇编语言机器m2操作系统机器m1传统机器(实际机器，微指令执行机器指令)m0微程序机器

### 总线
接入部分：片内，系统，通信
传输内容:数据，地址，控制

传输方式: 串行 并行 复用

阶段:申请分配=寻址=传数=结束

pci桥------------------------plug and play
pci -=-标准总线控制器----isa

总线控制:总线判优(仲裁)，总线通信控制
	总线仲裁 :集中式，分布式
		集中式:链式(BS BR BG)、计时器查询(BS BR  log2+2)，独立请求(BR BG)
	总线通信:
		同步，异步(三种锁)，半同步(等待响应线)，分离(两个子周期)
	
总线部件一般配有**三态门**控制

### 存储器(cpu连接大题)
主存:RAM(静态-触发器-速度高-集成低-贵，动态-电容-刷新)  ROM(系统程序区)
	串行访问:磁带(顺序存取)，磁盘(直接存取)

cpu-----cache-----主存------缓存
	缓存-主存:速度
	主存-辅存:容量
大小端              寻址范围-几根就是按字节寻址2的几次方

#### 主存与cpu的连接
**字、位扩展**
	位扩展(增加存储字长，):数据输出线D各接一部分()
	字扩展(增加存储字，):片选线判(加片选译码)  题一般138对应存储种类(ram/rom)+高位一根地址线 做与非
		==注意有片选字扩展了就得注意cpu地址线数== -1

片选线:cs **!CE**   
				线选法，重合法(横竖交叉)
额外的线: MREQ(cpu访存控制信号)  !CE(片选)    WR写 RD读  VCC正极-!PGM(rom接地用)

74138使能端G1 !G2a !G2b
				大题 画存储器cpu连接图:
				1地址空间，选片
				2连好连的，数据线 读写控制线 片子地址线
				3片选
				从高到低分别写RAM rom 16位地址(四位一16进制位
				区分全0到全1 刨开
				选片  扩展 (rom接地)
				搞74138(选之前没用的高位地址三位)从上到下CBA
				而看输出哪个就是看CBA的二进制对应十进制数Yi
#### 存储器校验
	海明码 2^k ≥ n+k +1  (n位k码)
	奇/偶校验: 奇最终为1，偶最终为0
生成:
	c1 负责标号13579 (标号的2进制第三位位1) 从左往右
	c2 负责(2进制第二位为1)
	c3负责(2进制最左位为1的)
	异或各自负责的数字，得到Ci(按奇/偶得到最终0还是1)
	然后按C1C2D1C3D2D3D4
纠错:
	生成检测位Pi，但是检测用P4P2P1(反过来) 
		P1 为C1 异或 C1的小组(标号)
		...
		
	偶校验:P4P2P1 = 000，不是这个则为对应二进制标号错误  已的个数为偶数
#### 提高访存速度的措施(交叉)
1高位交叉(顺序方式)          ==各个体并行工作==
高位地址可表示体号，低位地址为体内地址

2低位交叉(交叉方式)    ==各个体轮流编址==
低位地址用来表示体号，高位地址为体内地址
#### cache
效率e = 访问cache时间/平均访问时间 x 100%

##### 映像问题
直接映像
	直接映射：假设缓存共有C块，每个主存块j只与一个缓存块i对应，而每个缓存块可以和多个主存块对应，它们的映射关系是i=j mod C。实现简单，但主存块只能固定地对应某个缓存块，**不够灵活**，命中率低。
全相联映像
	全相联映射：主存中每一字块映射到Cache中的任何一块位置上，这种方式灵活，命中率也更高，缩小了块冲突率。但所需的逻辑电路甚多，**成本高**，实际的 Cache 还要采用各种措施来减少地址的比较次数。
组相联映像
是直接映射和组相联映射的一种折中。假设缓存共有Q组，每组内有R块，并用i表示缓存的组号，j表示主存的块号，它们的映射关系是i=j mod Q，即某个主存块j按模Q映射到缓存第i组内的任一块。这种方法比直接映射灵活，命中率高，比全相联映射成本低，是它们的折中，被广泛应用。
![[Pasted image 20251124162912.png]]
**做题：** 先算主存总容量(2的几次方)、块内位移(子块内地址，块大小)、主存块地址(2的几次方块 主存)
	对于直接，算cache块数地址(2的几次方表示cache数)，用总容-cache地址-位移得到标记
	对于全，只有标记和位移，算位移就行
	对于组，cache组数= 总块数/路，cache组数地址(2的几次方为组数) 得到组数    


替换策略
	FIFO,LRU(最近最少使用),随机
数据一致性
	写直达法  既写入cache又写入主存(增加访存次数)
	写回法   写只写入cache,当替换时才写回主存(需要设置标志位 清浊)


只看了选择

### io(程序查询，中断，DMA)
编码方式
	统一编码: io地址看作存储器地址一部分(无需专用io指令，占用存储器空间)
	不统一编码:io地址与存储器地址分开(专用io指令，不占用主存空间)

io与主机交换信息的控制方式
#### 程序查询方式(串行)
CPU 通过程序不断查询 I/0 设备是否己做好准备，从而控制 I/0 设备与主机交换信息。其特点是主机与I/O串行工作。(设备未准备则一直查询，效率低)
	接口电路? D完成触发器，B工作触发器
#### 程序中断方式(并行)
程序中断方式是指CPU 在启动 I/0 设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当 I/0 设备准备就绪并CPU 发出中断请求后才予以响应。其特点是主机与I/O并行工作。
	接口电路? INTR中断请求触发器，MASK屏蔽触发器，D,B,排队器
	![[Pasted image 20251124180441.png]]
	一次程序中断大致可分为五个阶段:
		中断请求  中断判优  中断响应  中断服务  中断返回
cpu发指令置B1D0-->接口启动输入->数据缓存寄存器->输入完成(D1)->设备D1Mask0,cpu发出中断查询->设备INTR1排队器判优->EINT1排队选中 响应 排队器输出生成向量地址->向量地址PC->中断服务 返回
##### 中断向量地址:中断服务程序入口地址的地址
#### DMA方式(并行)
主存与 I/0 设备之间有一条数据通路，主存与 I/0 设备交换信息时，无须调用中断服务程序。其特点是主机与I/O并行工作，主存与I/O之间有一条直接数据通路。当I/O准备就绪后，发出DMA请求，此时CPU不直接参与I/O和主存间的信息交换，只是把外部总线（地址线、数据线和有关的控制线）的使用权暂时交赋予DMA，仍然可以完成自身内部的操作（如加法、移位等），故不必中断现行程序，只需暂停一个存取周期访存（即周期挪用）
		DMA传送方式:**停止cpu访存，周期挪用，交替访问**(不需要申请归还总线使用权)
			·
	分为预处理，
			指明方向 设备地址 主存起始地址 传送数据个数 启动设备
	数据传输，
			继续执行主程序，同时完成一批数据的传送
	后处理(中断服务程序)
			中断服务程序 做DMA结束处理

DMA接口类型: 选择型与多路型
##### DMA与程序中断的中断请求区别: DMA是为了结束工作，后者是传送数据
##### DMA与中断特点: 中断靠程序-DMA靠硬件 中断指令执行完响应-DMA任一存取周期结束响应  中断可处理异常-DMA不能处理异常 中断需保护现场 DMA优先级高


#### io接口与端口

端口与接口
	接口是主机/cpu与io设备之间设置的硬件电路及软件控制
	端口是接口电路的一些寄存器

原因:实现io设备选择，速度匹配，数据格式，电平转换，状态

接口类型 (1)并行串行 (2)程序型DMA型

### 数 的计算与表示
移码:   [x]移 = 2^n +x   (n为整数的位数，x为真值有正负) n为阶码的数值位数，可以看作把原码阶符取反
000000 补= 100000 移 = 32
	最小真值的移码为全0

补码负数多一个
补码和移码+0=-0   原码和反码+0≠ -0
#### 浮点表示(IEEE 754)
N = S × r^j  (S尾数，r基数，j阶码(j为二进制表示))

单精度:![[Pasted image 20251126121053.png]] 全0全1抽出来，定义除了规格化浮点数以外的
![[Pasted image 20251126121232.png]]
把十进制数表示出二进制，然后科学计数法成1.xxxxxx 2^a(a为提了多少位)
然后计算刚刚的a+127的二进制数e
按照格式 符号  e  科学计数法去掉符号位及小数点，23位缺位补0

#### 定点计算
##### 算术左右移:保证与原来符号位相同
##### 加减法运算 计算补码
##### 乘法
乘法部分积相加，由乘数的末位决定被乘数是否与原部分积相加，然后右移一位形成新部分积，同时乘数右移一位，空出高位存放部分积的低位(如果乘数末位1则一直加的被乘数)
格式:
初始看乘数末位(加被乘数)，部分积为0

上一步部分积
逻辑右移位(部分积和乘数都移)  
+被乘数(上一步部分积末位决定 1加 0不加)

最后拼接部分积和乘数，看符号，出结果

##### 除法
加减交替法   x/y 上商n+1次
初始被除数原码符号位0 + (-y补)  | 商0

上一步被除数(余数)   (判断正负，正上1 负上0)
逻辑左移(余数和商一起)  
＋除数补码(商1)/+(-除数补码) (商0)
#### 浮点计算
##### 浮点加减 :对阶 尾数求和 规格化 溢出 舍入
(1.1)求阶差n      题一般阶是正的
(1.2)对阶: 小阶向大阶看齐，阶码小的尾数右移n位，阶码加n
(2)尾数求和:定点加减
(3)规格化：
*所有原码第一数位(点后)为1    补码0.1/1.0  反码0.1/1.0亦即数符和第一数位不同*
	特例: S=-1/2 **规定-1/2的补码不是规格化的数**
	左规:(前两位相同)尾数左移一位，阶码-1   (规格化使用)  移不是小数点
	右规:(前两位不同) 尾数右移一位，阶码+1 (对阶使用)
(4)舍入:0舍入1法 恒置1法
(5)溢出判断:
### 指令系统(扩展/设计指令大题)
#### 寻址方式
	确定本条指令操作数的地址，下一条指令的指令地址
指令寻址和数据寻址
数据寻址:    OP #(寻址特征) A
	1立即寻址 形式地址A就是操作数
	2直接寻址  有效地址由形式地址A给出
	3隐含寻址 操作数地址隐含在操作码OP中(如ADD 说明另一个操作数在ACC)
	4间接寻址 有效地址由形式地址间接提供  EA = (A) 
		执行阶段多次访存
	5寄存器寻址 有效地址即为寄存器编号 EA = Ri 
		执行阶段不妨村，只访问寄存器
	6寄存器间接寻址 有效地址在寄存器中 EA= (Ri)
		执行阶段访存；                      便于**编制循环程序**
	7基址寻址   EA = (BR)+A                  ==程序动态重定位==   
		(1)采用专用寄存器作基址寄存器BR
			执行过程BR内容不变，形式地址A可变；BR内容由os或管理程序决定
		(2)采用通用寄存器作基址寄存器BR
			由用户指定哪个通用寄存器位为BR;BR内容由操作系统确定;其他同上
	8变址寻址 EA=(IX)+A   IX为变址寄存器
		IX内容由用户给定;执行过程IX内容可变，形式地址A不变；==处理数组==
	9相对寻址 EA = (PC)+A  A是相对于当前指令的位移量->直接组成指令
	                           1              ==**程序浮动**==
	10堆栈寻址       先进后出，栈顶地址由SP指出    步幅与储存编制方法有关:按字编址+-1,按字节存储字长16位 +-2, 按字节存储字长32位+-4
		硬堆栈:多个寄存器     软堆栈:指定存储空间
		
![[Pasted image 20251205153808.png]]
#### 指令格式(设计)没有给出各方式条数
需要保留寻址特征位数M

#### 指令格式(扩展操作码)已给出各方式条数
不保留寻址特征! 已经区分开 好像问的只有操作码   从右往左推

没用到的都用做扩展
扩展核心: 上次留下n个操作码 乘 2^扩展的位数  = 新的可用的总操作码
	最后剩的码还要扩展，直接除 2^新扩展方式的地址码位数，得到新码

##### risc-v
R型
I型
J型

### CPU(中断大题)
取指(FE) 间址(IND) 执行(EX) 中断(INT)

#### 中断系统(中断隐指令，中断屏蔽字)
二 中断请求标记和判优
	1 中断请求标记  INTR  (单个请求源为一个intr触发器，多个intr为中断请求标记寄存器)
	INTR分散在各中断源的接口，INTR集中于CPU中断系统
	2 设置中断判优逻辑
	(1)硬件实现(排队器)
	(2)软件实现(程序查询)
三 cpu响应中断的条件与时间
	1条件:允许中断触发器 EINT =1
	2时间:执行周期结束由CPU发送查询信号
###### 什么是中断隐指令?
即在机器指令系统中没有的指令，他是cpu在中断周期内由硬件自动完成的一条指令
**保护程序断点**，**寻找中断程序的入口地址**，关中断

四 保护现场和恢复现场
1保护现场
	断点: 中断隐指令完成           寄存器内容:中断服务程序完成
2恢复现场   中断服务程序完成
中断返回: 由中断服务程序最后一条中断返回指令完成

五 中断服务程序入口地址的查找
	1硬件向量法
	2软件查询法

进入中断周期做的事的顺序: 保存断点-形成中断服务程序入口地址-关中断(前三个中断隐指令)，保护现场，中断服务，恢复现场，中断返回

SP-1-->MAR; 1-W;关中断
PC->MDR;
MDR->(MAR);向量地址->PC
##### 中断屏蔽技术(大题，屏蔽码和图画) 
###### 什么是中断屏蔽字？
对每个INTR触发器都有屏蔽触发器，将所有屏蔽触发器组合在一起就是屏蔽寄存器，屏蔽寄存器的内容称为屏蔽字，与中断源的优先级一一对应


多重中断的断点保护
(1)断点进栈  中断隐指令完成       (2)断点存入0地址  中断隐指令完成

### 控制单元
微操作命令的分析
1 取值周期微操作
PC->MAR;  1->R;   M(MAR)->MDR;   MDR->IR;  op(IR)->CU;  PC+1->PC
2 间址
Ad(IR)->MAR ; 1->R ; M(MAR)->MDR ;  MDR->Ad(IR);
4 中断
(SP)-1->MAR; 1->W; PC->MDR; MDR->(MAR); 向量地址->PC; 关中断
##### 多级时序系统
1 机器周期:所有指令执行过程中的一个基准时间
	基准时间确定:完成最复杂指令功能时间为准；访问一次存储器的时间为基准；
若指令字长=存储字长        取指周期 = 机器周期
2 节拍: 用时钟信号控制节拍发生器所产生，每个节拍的宽度对应一个时钟周期(控制计算机操作的最小时间单位)
**什么是多级时序？**
	机器周期和节拍构成了多级时序系统； 一个指令周期包含若干机器周期，一个机器周期包含若干时钟周期；每个指的机器周期数可不等，每个机的时钟周期数可不等
**主频是时钟周期的倒数，指令周期 = 1/ 指令执行速度MIPS**
**MIPS与主频f成正比！计算题**
mips = 时钟频率/cpi    cycle/second  // cycle/instruction  --> instruction / second


控制方式
1 同步控制方式
	(1)采用完全统一节拍的机器周期(定长)
		以最长的微操作序列何最繁的微操作为标准
	(2)采用不定长的机器周期
	(3)采用中央控制何局部控制相结合的方法
2 异步控制方式
3 联合控制方式

双字长 取指周期访问两次 (两次PC+1)
### 控制单元的实现(组合逻辑/微程序设计)
#### 组合逻辑设计
1 微操作节拍的安排(同步控制，一周期三节拍)
	(1)有些微操作次序不容改变(2)被控对象不同微操作放一个节拍(3)占用时间短的安排在一个节拍内，并允许有先后顺序
2 组合逻辑设计步骤
(1)列出微操作命令的操作时间表
(2)写出微操作命令的最简表达式(M(MAR)->MDR一般在三周期的第二个)
(3)画出逻辑图

*思路清晰，简单明了|| 调试困难，修改困难 || 速度快(RISC)*
#### 微程序设计
**简述微程序设计的思想**
将一条机器指令编写成一个微程序，每一个微程序包含若干微指令，每一条微指令对应一个或多个 微操作命令。把这些微程序存到一个控制存储器里，用寻找用户程序机器指令的方法来寻找每个微程序中的微指令。由于这些微指令由二进制代码形式表示，每位代表一个控制信号，因此逐一执行每条微指令也就相应的完成了每条机器指令的全部操作
可见微程序控制单元的核心部件是一个控制存储器

微指令格式: 操作控制字段(产生控制信号) + 顺序控制字段(下一条微指令地址


微指令的编码方式(控制方式   **这三都是水平型？**
1 直接编码(直接控制)
	每一位的代表一个微操作命令    速度最快
2 字段直接编码方式 
	控制字段分成若干段，每段译码后发出控制信号    显式编码，微程序执行速度较慢
		每个字段命令是互斥的     缩短了微指令字长，增加了译码时间
3 字段间接编码方式



**概念区分: 微命令(控制信号)   微操作(基本操作)        微指令(微命令集合)**
μPC不能取代PC，因为μ里是控制执行顺序，而PC指示地址
###### 微指令序列地址的形成
1 直接由微地址下地址字段给出(断定)
2机器指令的操作码形成(有机器码时)
3增量计数器法 CMAR+1->CMAR
4各种标志决定微指令分支转移地址
5测试网络形成
6硬件直接产生微程序入口地址



**什么是水平型微指令(直接控制--长)，什么是垂直型微指令(编码控制--短)**
（1）水平型微指令
    水平型微指令的特点是一次能定义并执行多个并行操作的微命令。图 10.7 就是典型的水平型微指令。从编码方式看，直接编码、字段直接编码、字段间接编码以及直接和字段混合编码都属千水平型微指令。其中，直接编码速度最快，字段编码要经过译码，故速度受影响。
（2）垂直型微指令
    垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令字中，设置微操作码字段，由微操作码规定微指令的功能。通常一条微指令有 1~2 个微命令，控制 1~2 种操作。这种微指令不强调其并行控制功能。
（3）两种微指令格式的比较
①水平型微指令比垂直型微指令并行操作能力强、效率高、灵活性强。
②水平型微指令执行一条机器指令所需的微指令数目少，因此速度比垂直型微指令的速度快。
③水平型微指令用较短的微程序结构换取较长的微指令结构，垂直型微指令正相反，它以较长的微程序结构换取较短的微指令结构。
④水平型微指令与机器指令差别较大，垂直型微指令与机器指令相似。

### 流水线？
加速比: m段流水线速度/等功能非流水线速度之比  mn/m+n-1  T0/Tk 理想情况下为段数
最高吞吐率: 1/最慢一段时钟周期
实际吞吐率: n / T(n个指令[不是段]需要时间-时钟周期数)
效率:     流水线各段工作时间的时空区/隔断总时空区

dcbdc cdcda bcbad