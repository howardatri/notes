明天六级 X


下周数据结构上机，11号下午复习  复习了关键路径，floyd啥的
马原得看起来了

单链表: 重要在于判空和 p->next = q->next一定写 不能只写p->next = q，后续指向都没了

栈: 两个数组模拟， 
	写了汉诺塔非递归 Dp             12.14

kmp  注意我这种0-based写法，j=`next[j-1]`要取最长/次长前后缀长度也得取`next[n-1]n为串长` 判断最长存在后才能取次长 12.15

复习了bfs和dfs,但是dfs的建图很麻烦 链表升序，考虑三种情况
	图的dfs： 不要用链式前向星，而是使用vector< i nt > map[n] 或vector<vector< i n t>>map这样的邻接表，然后再sort(map[x].begin(),map[x].end())进行字典序排序
	dfs需要参数map visited 目标值 result vector都是引用

二叉树层序遍历注意点: 在每层的循环里弹出节点，包括最开始第0层的根，这样才循环                 12.12

二叉树删除子树，注意找返回pair目标节点和父节点(传入parent =null) 
	每次判断都是判断目标节点而不是父节点
	对于递归，利用一个中介p,if return 左，else 返回右

重建二叉树: 注意下标 ， 中序的右子树是+k+1，长度是n-k-1
	12.12    height函数!root返回-1，否则max   12.15 
	#递归通用 注意树这有递归且参数root的都得最开始判断root 最后返回值/回溯        isvalid(长度为0合法 递归最底层)-各种序遍历

根到叶值k： 结果型dfs,不需要返回值，用vector&记录结果即可
	注意点:  dfs分支为是否为叶节点(if else,继续dfs在else里)，然后回溯(pop_back)
		dfs步骤: 判断根合法 加入 判断结果分支  回溯

a->b路径：存在型dfs()，返回bool      判断 加入  若是则true   分支(if(dfs)) 回溯(弹出还要返回false)
记录的是lca索引，所以初始化为0，利用索引加入路径
	加入结果时，循环的上/下限是各路径自身

括号匹配: ==cin.get吸收换行符 getline(cin,str)读整行==  valid变量记录 `newmatch参数传入栈，因为要判空   ` newmatch开始一定要判空
右括号判断 空？ 匹配？
最后判断空

表达式求值   中转后(分左( 右)两个条件,数字，运算符(三个条件))   参数string返回vector< string>  用到一个运算符栈和vector< string>(包括了string(1,char)) ，再计算 ---参数一个vector< string> 返回字符串 (result to_string)
	12.14

珍珠项链 12.15 注意输出 这题只用到了p/head数组

哈夫曼放了

bfs悟空救唐僧:  结构体x y和步数，最后终点是steps+1包括终点那一步(这个影响最后输出 steps-T+1的+1)              12.12
	while循环里 先弹，判断是否结束，四个方向遍历，判断是否可走(加入队列并visited step++)
	别忘了visited数组   12.15


拓扑排序:   把入度为0的点全加入队列再循环
若使用了优先队列， ==循环变成了for n个顶点==，判断就是每轮循环开始是队列是否为空              12.12                                最特殊就这个for循环判非空，其他图论基本都是while的
	弹出后加入结果，并循环与该顶点相连的其他顶点 减入度-判断为0则加入队列
12.15
关键路径:    图存储pair<邻接点，权重>
		对于vl，由于倒着算，所以赋完初值ve`[topo[n-1]]`之后要从n-1开始遍历
	ve(ve`[topo[i]]+weight>ve[j]`)  vl(`vl[j]-weight<vl[topo[i]] ` ) ee ll 
手写一遍bug还挺多
	数组都得初始化，由于1索引所以所有数组(n+1,0)初始化，所有循环1到<=n
	但是计算ve vl的时候赋完初值 要从0开始遍历，因为topo数组是vector 0索引，并且
		这里遍历的都是for(auto k : map`[topo[i]]`)  额外蝶一层topo
	最后ee 是ve`[i]`,el是`vl[veradj]-weight` 结果加入为(i,veradj)

diji floyd prim